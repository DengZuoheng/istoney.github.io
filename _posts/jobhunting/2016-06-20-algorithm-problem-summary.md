---
layout: post
title: Algorithm Problems Summary
category: Job Hunting
tags: [Job]
---
{% include JB/setup %}

| 分类 | 子类 | 题目编号 |
| -- | -- |
| [数组](#数组) | [数组求和](#数组求和) | 1, 15, 16, 18 |
| [整数表示与计算](#整数表示与计算) | | 66, 67, 2, 43 |
| [二进制计算](#二进制计算) | | 371 |
| [字符串](#字符串) | | 3 |
| [字符串](#字符串) | [回文](#回文)| 5 |
| [查找](#查找) | | 4 |


## 1. 数组

### 1.1 数组求和

**Two Sum** `leetcode` `Easy`

> 给定整数数组，返回和为目标值的两个数的下标，结果唯一.

1. 排序后双指针夹逼，因为结果为下标，排序时需要将下标跟随值异同排序，复杂度\\( O(nlogn) \\)；
2. Hash表记录每个数及下标，遍历查找，复杂度\\( O(n) \\).

**3Sum** `leetcode` `Medium`

> 给定整数数组，返回所有和为0的三元组，不得重复.

1. 对数组排序，然后从头遍历数组选取第一个数，再从第一个数之后的范围内选取另外两个数；**第一个数<=0,可进行剪枝**，且遇到相同数只计算一次。复杂度\\( O(n^2) \\).

**3Sum Closest** `leetcode` `Medium`

> 给定一个数组和一个目标值target，找出和与target最接近的三个数，将和返回。

1. 同3Sum，先排序，遍历选取第一个数，然后双指针夹逼计算twoSum.

**4Sum** `leetcode` `Medium`

> 给定一个整数数组和目标值target，找出所有和为target的四元组。

1. 类似3Sum，排序后遍历选取第一个数，然后从第一个数后再遍历选取第二个数，然后再第二个数之后的范围内就算twoSum. 计算时注意剪枝, 复杂度\\( O(n^3) \\).
2. 首先计算所有两个数的和，存入Hash表，替换twoSum计算, 复杂度\\( O(n^2) \\).

**类型总结**

- 求k个数的和等于target，首先对数组排序；
- 若k为2，则采用双指针夹逼，若k大于2，则遍历元素，将其转化为k-1；
- 注意剪枝，例如遍历时，k个连续元素和大于target，则停止遍历...
- 可采用Hash表缓存两个数的和，替换twoSum计算；

---

## 2. 整数的表示与计算

**Plus One `leetcode` `Easy`**

> 给定一个用digits数组表示的整数，高位数字在数组投头部，求该整数加一的结果。

1. 要加的1可以看作最低位的进位，记录进位循环计算，直到没有进位位置；加到最高位时若存在进位，需要在数组头部insert。

**Add Binary** `leetcode` `Easy`

> 给定两个二进制字符串，计算其二进制和，仍以字符串形式返回。

1. 遍历字符串相加，用一个变量记录进位；注意字符串顺序与数字顺序相反。

**Add Two Numbers** `leetcode` `Medium`

> 给定两个用单链表表示的非负整数，每个节点上为1个digit，倒序存储，求这两个这个整数的和。

1. 同步遍历链表相加，用一个变量记录进位，复杂度\\( O(m+n) \\).

**Multiply Strings** `leetcode` `Medium`

> 给定用字符串表示的两个整数，返回字符串表示的两数乘积；两数非负，可能会很大；禁止使用转换函数和内置BigInteger。

1. 双重循环计算乘法，注意进位；复杂度\\( O(m*n) \\)。

---

## 3. 二进制计算

**Sum of Two Integer** `leetcode` `Easy`

> 不使用`+`和`-`计算符，计算两个整数的和。

1. 计算亦或作为和，两数与作为进位，进位左移一位，递归计算，直到没有进位。

---

## 4. 字符串

### 4.1

**Longest Substring Without Repeating Characters** `leetcode` `Medium`

> 给定一个字符串，找出没有重复字符的最长字串的长度。

- 以哈希表记录每个字符出现的位置，此处哈希表用长度为256的字符数组代替；
- 变量start记录本次无重复字串的开始位置，遍历字符串，查找字符上次出现位置；
- 若出现在start之前，更新其位置，若出现在start之后说明重复，更新start为该字符上次位置的下一个，重新开始。复杂度\\( O(n) \\)。

### 4.2 回文

**Longest Palindromic Substring** `leetcode` `Medium`

> 给定字符串S，求其最长回文字串，S长度最大为1000，最长字串唯一。

- 字符中间插入额外的'#'，使计算简单;
- 计算以每个字符为中心的回文串半径长度，从中选取最长；
- 计算中，记录当前最靠后的回文串尾部位置max，及其中心位置，若i小于max，则p[i] = min(p[2*max-i], max-i)；否则为1；

## 查找

**Median of Two Sorted Arrays** `leetcode` `Hard`

> 给定两个排序数组，求其所有数的中位数，要求算法复杂度为\\( O(log(m+n)) \\)。

1. 首先分别查找两个数组的中位数，对其进行比较，若相等返回，若一大一小，选取两个数组长度小的一个的一半作为裁剪长度，从中位数小的数组前部减去该长度，从中位数大的数组的后部减去该长度；递归。
2. 查找第k大的数：若两个数组长度均大于k/2，从两个数组分别去其第k/2大的数，若相等，返回该值；不相等，则删除值较小的所在数组的前k/2个数。若其中一个数组长度小于k/2（则另一个数组长度应大于k/2），此时去数组1的全部长度len，取数组2的k-len长度的数进行比较。递归。
